% --------------------------------------------------------
% Restating to the thesis
% --------------------------------------------------------
Cân bằng tải là một vấn đề kinh điển trong HPC. Trong đó, cách tiếp cận để giải quyết phần lớn phụ thuộc vào tình huống và nguyên nhân gây ra sự mất cân bằng. Công việc của chúng tôi tập trung vào sự mất cân bằng của các ứng dụng dạng task-based parallel khi thực thi trên hệ thống bộ nhớ phân tán. Cụ thể, tình huống này có thể hình dung khi ứng dụng của chúng ta có một số lượng tasks cần tính toán, được gán đều cho các đơn vị thực thi điển hình gọi là các processes. Lưu ý rằng với các kiến trúc tính toán đa nhân ngày nay và mô hình lập trình mới như task-based parallel programming models thì một process được gán tới một multicore processor, trong đó chúng ta có thể tạo nhiều threads trong một process, các threads đuợc map tới các cores và đóng vai trò thực thi tasks song song. 

Liên quan tới sự mất cân bằng, nguyên nhân chính gây ra bởi performance slowdown xảy ra một cách đột nhiên trên một số processes, khiến chúng thực thi chậm hơn bình thường. Qua đó, cách duy nhất để cân bằng tải là chia sẻ tasks từ process chậm sang process nhanh. Tuy nhiên, một thách thức đó là sự liên quan đến phí tổn giao tiếp khi viêc di chuyển tác có thể chậm đi. Điều này đòi hỏi cần có một cách tiếp cận thích hợp để thực hiện việc di chuyển bao nhiêu tasks là hợp lý và từ process nào đến process nào.

% --------------------------------------------------------

Load balancing is a classic problem in HPC. The approach to solving it largely depends on the situation and the cause of the imbalance. Our work focuses on the imbalance of task-based parallel applications when executing on distributed memory systems. Specifically, this situation can be imagined when our application has a number of tasks that need to be calculated, equally assigned to typical execution units called processes. Note that with today's multicore computing architectures and new programming models such as task-based parallel programming models, a process is assigned to a multicore processor, in which we can create multiple threads in a process, the Threads are mapped to cores and play the role of executing tasks in parallel.

Regarding imbalance, the main cause is performance slowdown that suddenly occurs on some processes, causing them to execute slower than usual. Thereby, the only way to balance the load is to share tasks from slow processes to fast processes. However, one challenge is the communication overhead involved as collaboration can be slow. This requires an appropriate approach to moving as many tasks as appropriate and from process to process.

% --------------------------------------------------------
% Summarize key points
% --------------------------------------------------------
Trong quá trình nghiên cứu, chúng tôi nhận ra một số điểm mấu chốt như sau:
1. Cách tiếp cận kinh điển phụ hợp để cân bằng tải động cho bài toán của thesis này là work stealing. Work stealing được nghiên cứu khá phổ biến trong hệ thống bộ nhớ chia sẻ. Tuy nhiên, communication trong hệ thống bộ nhớ phân tán gây trở ngài cho cách tiếp cận này bởi vì stealing một task có thể tốn thời gian dẫn đến số lượng tasks có thể steal bị giới hạn.
2. Cách tiếp cận khá mới là reactive load balancing. Nó được xem như là một sự cải thiện và state-of-the-art. Reactive load balancing tận dụng mô hình lập trình task-based và kiến trúc tính toán đa nhân để thực hiện reactive task migration. Khác với cơ chế pull-oriented của work stealing trong hệ phân bố, cách tiếp cận reactive sử dụng 1 thread chuyên dụng trong mỗi process để liên tục kiểm tra tình trạng thực thi nhanh hay chậm trên mỗi process. Qua đó, khi sự mất cân bằng xảy ra, task có thể được migrate một cách phản ứng và sớm hơn work stealing. Tuy nhiên, chúng tôi thấy rằng cách tiếp cận này khá rủi ro trong trường hợp mất cân bằng lớn bởi vì việc migrate task một cách reactively chỉ dựa trên tình trạng thực thi tại một thời điểm tức thời và nó khá đầu cơ. Qua đó, số lần migrate tasks sai có thể xảy ra thường xuyên trong một số trường hợp như, số lượng tasks nhiều, tải của mỗi task không quá lơn, và độ mất cân bằng cao.
3. Các yếu tố ảnh hưởng đến việc cân bằng tải động bao gồm đặc điểm ứng dụng lẫn hệ thống. Trong đó, đặc điểm ứng dụng có thể formulate qua các yếu tố: số lượng tasks, scale thực thi điển hình là số lượng node tính toán, process, kích thước dữ liệu của tasks. Còn đặc điểm hệ thống bao gồm: phí tổn communication, performance variability.
4. Cả hai cách tiếp cận work stealing và reactive load balancing cho việc cân bằng tải trong lúc thực thi đều có thể thực hiện khá chậm do hành vi của chúng trong hệ thống bộ nhớ phân tán. Ví dụ, work stealing bắt đầu stealing task khi một trong các process idle, còn reactive load balancing operations thì khá là đầu cơ.
5. Điểm quan trọng của việc cân bằng tải động nói chung và áp dụng cho ngữ cảnh của chúng tôi nói riêng là thiếu thông tin về tải lúc thực thi. Điều này có thể dễ hiểu cho việc hầu hết các cánh tiếp cận hiện nay đều dựa trên các thông tin ít hỏi suy ra từ queue length của mỗi process.

% --------------------------------------------------------

Through the research process, we realized some key points as follows:
1. The classic approach suitable for dynamic load balancing for this thesis problem is work stealing. Work stealing is widely studied in shared memory systems. However, communication in distributed memory systems hinders this approach because stealing a task can be time-consuming, which limits the number of tasks that can be stolen.
2. A fairly new approach is reactive load balancing. It is seen as an improvement and state-of-the-art. Reactive load balancing leverages the task-based programming model and multi-core computing architecture to perform reactive task migration. Different from the pull-oriented mechanism of work stealing in distributed systems, the reactive approach uses a dedicated thread in each process to continuously check the fast or slow execution status of each process. Thereby, when an imbalance occurs, tasks can be migrated reactively and earlier than work stealing. However, we find that this approach is quite risky in the case of large imbalances because migrating tasks reactively is only based on the execution status at one instant in time and is quite speculative. Thereby, the number of times migrating incorrect tasks can occur frequently in some cases such as, the number of tasks is large, the load of each task is not too large, and the imbalance is high.
3. Factors affecting dynamic load balancing include both application and system characteristics. In particular, application characteristics can be formulated through factors: number of tasks, execution scale, typically the number of calculation nodes, processes, data size of tasks. System characteristics include: communication costs, performance variability.
4. Both work stealing and reactive load balancing approaches for load balancing during execution can be quite slow due to their behavior in distributed memory systems. For example, work stealing starts stealing tasks when one of the processes is idle, while reactive load balancing operations are quite speculative.
5. The important point about dynamic load balancing in general and applied to our context in particular is the lack of load information at runtime. This is understandable since most current approaches are based on little information inferred from the queue length of each process.

% --------------------------------------------------------
% Highlight implications and contributions
% --------------------------------------------------------

Qua đây, chúng tôi nhận thấy rằng để phân tích bài toán cân bằng tải động và giới hạn của các cách tiếp cận hiện tại cần có một mô hình hiệu xuất nhất định. 
Điều này ngụ ý đóng góp thứ nhất của chúng tôi, một mô hình hiệu suất mới cho việc cân bằng tải động. Cụ thể, chúng tôi xây dựng mô hình này để simulate hàn vi cân bằng tải của cách tiếp cận reactive load balancing thông qua các hành động được thực hiện liên tục và tự phát tại runtime như monitoring executiong status, exchanging status, checking imbalance, and offloading tasks. Các hành vi này được mô hình hoá dựa trên discrete time model. Qua đó, chúng tôi gộp monitoring, exchanging, và checking thành tham số phí tổn cân bằng ngụ ý phí tổn trung bình cho các balancing operations. Còn offloading task được phân thành phí tổn của task migration. Thông thường, các công trình nghiên cứu liên quan đa phần tập trung vào phí tổn của task migration bởi vì communication trong hệ thống bộ nhớ phân tán có thể đối mặt độ trễ phí tổn lớn điển hình là delay time (d). Tuy nhiên, thông qua mô hình hiệu suất được đề xuất, chúng tôi nhận thấy rằng phí tổn liên quan đến balancing operations trước khi một task được migrate góp phần khá lớn bởi vì nếu số lượng task nhiều, độ mất cân bằng cao, các operations này không phải thực hiện ít. Tuy the cost của mỗi operation không lớn, nhưng số lần thực hiện nhiều mang đến một ảnh hưởng khá lớn. Điều này dẫn đến độ trễ lớn trước khi một task được migrate. Một điểm khác là các cách tiếp cận hiện tại thường không có prior-knowledge trong lúc thực thi, do đó những balancing operations này thực hiện liên tục với số lượng lớn là không thể tránh khỏi. Đồng thời chỉ dựa vào tình trạng thực thi tại một thời điểm nhất định để quyết định migrate tasks là không đủ.

Qua đó, điều này ngụ ý đóng góp thứ hai, a proactive load balancing approach. Ý tưởng chủ yếu là việc tạo ra knowledge thông qua dự đoán tải tại runtime. The load prediction giúp xác định mức độ cân bằng, process nào overloaded, process nào underloaded. Điều quan trọng chúng ta có thể ước lượng tốt hơn số lượng task cần migrate để cân bằng tải. Chúng tôi đã cho thấy our proactive approach work thông qua hai methods:
- fb
- ml-based
Bản hiện thực của 2 phương pháp này được thiết kế như 1 plugin tool cho một task-based programming framework, Chameleon. Độ hiệu quả được đánh giá thông qua các thực nghiệm trên microbenchmarks và 1 ứng dụng thực tế gọi là Sam(oa). Nhìn chung, kết quả speedup đạt được trung bình từ 1.7x - 3.5x trong các trường hợp mất cân bằng lớn.

Thêm vào đó, cách tiếp cận của chúng tôi còn hỗ trợ một ý tưởng mới: co-scheduling tasks across multiple applications. Phạm vi scheduling tasks bây giờ được mở rộng giữa các ứng dụng task-based thực thi đồng thời. Mục đích là chia sẽ tasks để tối ưu sử dụng tài nguyên, cân bằng tải.


Through this, we realize that to analyze the dynamic load balancing problem and the limitations of current approaches, a certain performance model is needed. This is also a motivation for our first contribution. This implies our first contribution, a new performance model for dynamic load balancing. Specifically, we build this model to simulate the load balancing behavior of the reactive load balancing approach through actions that are continuously and spontaneously performed at runtime such as monitoring executing status, exchanging status, checking imbalance, and offloading tasks. These behaviors are modeled based on a discrete time model. Thereby, we combine monitoring, exchanging, and checking into a balancing cost parameter that implies the average cost for balancing operations. And offloading tasks is classified into the cost of task migration.

Thereby, this implies the second contribution, a proactive load balancing approach. The main idea is knowledge generation through load prediction at runtime. The load prediction helps determine the level of balance, which processes are overloaded, which processes are underloaded. The important thing is that we can better estimate the number of tasks that need to be migrated to balance the load. We have shown our proactive approach work through two methods:
- fb
- ml-based
The implementation of these two methods is designed as a plugin tool for a task-based programming framework, Chameleon. Efficiency is evaluated through experiments on microbenchmarks and a practical application called Sam(oa). Overall, speedup results average between 1.7x - 3.5x in large imbalance cases.

In addition, our approach supports a new idea: co-scheduling tasks across multiple applications. The scope of scheduling tasks is now extended between concurrently executing task-based applications. The purpose is to share tasks to optimize resource use and balance load.


% --------------------------------------------------------
% Limitations and Future Works
% --------------------------------------------------------
Nevertheless, our work còn những hạn chế liên quan đến mô hình hiệu suất và the proactive load balancing. Những điểm này ngụ ý các hướng nghiên cứu có thể mở ra trong tương lai.

% --------------------------------------------------------
% Ending Statement - End on strong note
% --------------------------------------------------------
Sau tất cả, chúng tôi có thể kết luận rằng việc tối ưu cân bằng tải động trong hệ phân bố cần sự cân nhắc giữa chiến lược (chủ động hay bị động) và thời gian thực thi (task và migrating task). Chiến lược liên quan đến chủ động và bị động, tác vụ và phí tổn của chúng; còn thời gian thực thi liên quan đến task và phí tổn migrate tasks. Ứng với kiến trúc tính toán hiện tại và mô hình lập trình mới như task-based programming models, cách tiếp cận của chúng tôi cho thấy sự khả thi và hiệu quả nhất đinh. Đặc biệt, chúng tôi leverage machine learning như là một tool support load balancing. Cho một tầm nhìn lâu dài, công việc này phụ hợp với xu hướng ứng dụng tự động tuning và lập lịch dựa trên các luật cũng như chính sách của con người. 

After all, we can conclude that optimizing dynamic load balancing in distributed systems requires consideration between strategy (active or passive) and execution time (task and migrating task). Strategy concerns active and passive, tasks and their costs; There is also the execution time associated with the task and the cost of migrating tasks. Adapting to current computing architectures and new programming models such as task-based programming models, our approach shows certain feasibility and efficiency. In particular, we leverage machine learning as a load balancing support tool. For a long-term vision, this work is compatible with the trend of applying automatic tuning and scheduling based on human rules and policies.

